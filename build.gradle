import net.darkhax.curseforgegradle.TaskPublishCurseForge

plugins {
    id 'idea'
    id 'java-library'
    id 'maven-publish'
    id 'net.neoforged.moddev' version '2.0.137'
    id("net.darkhax.curseforgegradle") version "1.1.26"
}

// Capture original values from gradle.properties before any reassignment
def _fallbackModVersion = mod_version
def _fallbackReleaseType = release_type

def getGitDescribedVersion = { ->
    def described = providers.exec {
        commandLine 'git', 'describe', '--tags', '--dirty=-local', '--candidates=100', '--always'
    }.standardOutput.asText.get().trim()
    // When no tags exist, --always returns just the commit hash (optionally with -local suffix).
    // Fall back to mod_version-release_type-gHASH for a meaningful version string.
    if (described ==~ /[0-9a-f]{7,40}(-local)?/) {
        def dirty = described.endsWith('-local') ? '-local' : ''
        def hash = described.replace('-local', '')
        def base = _fallbackModVersion + (_fallbackReleaseType != 'release' ? "-${_fallbackReleaseType}" : '')
        return "${base}-g${hash}${dirty}"
    }
    return described
}

def getGitDescribedVersionWithMcVersion = { ->
    return "$minecraft_version-${getGitDescribedVersion()}"
}

allprojects {
    version = getGitDescribedVersion()
    group = mod_group_id
}

if (System.env.BUILD_SERVER_PUBLISH != null) {
    if (version != mod_version + (release_type != "release" ? "-$release_type" : "")) {
        throw new VerificationException("Expected described version '${mod_version + (release_type != "release" ? "-$release_type" : "")}' got '$version'")
    }
}

// use the git described version instead, its got more info than just the normal mod version
mod_version = "${getGitDescribedVersion()}"

base {
    archivesName = "$mod_id-neoforge-$minecraft_version"
}

def lwjglJavaLibs = [
        "vulkan",
]

def lwjglNativeLibs = [
        "shaderc",
        "spvc",
        "vma",
]

def lwjglNativePlatforms = [
        "natives-linux",
        "natives-linux-arm64",
        "natives-macos",
        "natives-macos-arm64",
        "natives-windows",
        "natives-windows-arm64",
]

loaderLibsToPack = []
def nativeLibsToUse = []
vkJavaLibs = []

for (lib in lwjglJavaLibs) {
    var baseLibName = "org.lwjgl:lwjgl-$lib:$lwjglVersion"
    loaderLibsToPack.add(baseLibName)
    vkJavaLibs.add(baseLibName)
}

for (lib in lwjglNativeLibs) {
    var baseLibName = "org.lwjgl:lwjgl-$lib:$lwjglVersion"
    loaderLibsToPack.add(baseLibName)
    vkJavaLibs.add(baseLibName)
    for (nativePlatform in lwjglNativePlatforms) {
        nativeLibsToUse.add(baseLibName + ":$nativePlatform")
        loaderLibsToPack.add(baseLibName + ":$nativePlatform")
    }
}

loaderLibsToPack.add("org.lwjgl:lwjgl-vulkan:$lwjglVersion:natives-macos")
loaderLibsToPack.add("org.lwjgl:lwjgl-vulkan:$lwjglVersion:natives-macos-arm64")

evaluationDependsOn(":loader")

configurations {
    builtModJar {
        canBeConsumed = true
        canBeResolved = true
    }
    jijMod {}
    jijLib {}
    loader {}
}

repositories {
    maven { url "https://maven.neoforged.net/releases" }
    maven { url "https://libraries.minecraft.net/" }
    mavenCentral()
    mavenLocal()
    maven {
        name 'Maven for PR #2297' // https://github.com/neoforged/NeoForge/pull/2297
        url 'https://prmaven.neoforged.net/NeoForge/pr2297'
        content {
            includeModule('net.neoforged', 'neoforge')
        }
    }
}

java.toolchain.languageVersion = JavaLanguageVersion.of(25)

sourceSets {
    // externally accessible API
    api {
        //The API has no resources
        resources.srcDirs = []
        compileClasspath += main.compileClasspath.filter { File element ->
            // API requires javax.annotation for TypeQualifierDefault
            return true
        }
        annotationProcessorPath += main.annotationProcessorPath
    }
    // internal library
    lib {
        compileClasspath += api.output
        compileClasspath += main.compileClasspath.filter { File element ->
            // MC and all related classes
            if (element.name.startsWith("neoforge")) {
                return false
            }
            // javax.annotation
            if (element.name.startsWith("annotations-3.0.1") || element.name.startsWith("jsr305")) {
                return false
            }
            return true
        }
        annotationProcessorPath += main.annotationProcessorPath
    }
    // internal library, parts that need access to MC
    mclib {
        java {
            srcDirs = ['src/libmc/java']
        }
        compileClasspath += api.output
        compileClasspath += lib.output
        compileClasspath += main.compileClasspath.filter { File element ->
            // javax.annotation
            if (element.name.startsWith("annotations-3.0.1") || element.name.startsWith("jsr305")) {
                return false
            }
            return true
        }
        annotationProcessorPath += main.annotationProcessorPath
    }
    // the main renderer core
    core {
        resources.srcDirs = []
        compileClasspath += api.output
        compileClasspath += lib.output
        compileClasspath += mclib.output
        compileClasspath += main.compileClasspath.filter { File element ->
            // javax.annotation
            if (element.name.startsWith("annotations-3.0.1") || element.name.startsWith("jsr305")) {
                return false
            }
            return true
        }
        annotationProcessorPath += main.annotationProcessorPath
    }
    mercury {
        compileClasspath += api.output
        compileClasspath += lib.output
        compileClasspath += main.compileClasspath.filter { File element ->
            // MC and all related classes
            if (element.name.startsWith("neoforge")) {
                return false
            }
            // javax.annotation
            if (element.name.startsWith("annotations-3.0.1") || element.name.startsWith("jsr305")) {
                return false
            }
            return true
        }
        annotationProcessorPath += main.annotationProcessorPath
    }
    main {
        java {
            srcDirs = ["src/mod/java"]
        }
        resources.srcDirs = ["src/mod/resources"]
        compileClasspath += api.output
        compileClasspath += core.output
        compileClasspath += lib.output
        compileClasspath += mclib.output
        compileClasspath += mercury.output
    }
}

neoForge {
    version = project.neo_version

    accessTransformers = project.files('src/mod/resources/META-INF/accesstransformer.cfg')

    runs {
        CinnabarRelease {
            client()
        }
        CinnabarAssert {
            client()
            jvmArguments.addAll("-ea:graphics.cinnabar...", "-Dcinnabar.debugLogging=true")
        }
        CinnabarDebug {
            client()
            jvmArguments.addAll("-ea:graphics.cinnabar...", "-Dcinnabar.debugLogging=true", "-Dcinnabar.vulkanValidationLayers=true", "-Dcinnabar.mercuryValidationLayers=true")
        }
        CinnabarTraceDebug {
            client()
            jvmArguments.addAll("-ea:graphics.cinnabar...", "-Dcinnabar.traceLogging=true", "-Dcinnabar.vulkanValidationLayers=true", "-Dcinnabar.mercuryValidationLayers=true")
        }
        CinnabarRenderDoc {
            client()
            environment.put("ENABLE_VULKAN_RENDERDOC_CAPTURE", "1")
            jvmArguments.addAll("-ea:graphics.cinnabar...", "-Dcinnabar.traceLogging=true", "-Dcinnabar.vulkanValidationLayers=true", "-Dcinnabar.mercuryValidationLayers=true")
        }

        configureEach {
            systemProperty 'forge.logging.markers', 'REGISTRIES'
            logLevel = org.slf4j.event.Level.DEBUG
        }
    }

    mods {
        "${mod_id}" {
            sourceSet(sourceSets.api)
            sourceSet(sourceSets.core)
            sourceSet(sourceSets.lib)
            sourceSet(sourceSets.mclib)
            sourceSet(sourceSets.mercury)
            sourceSet(sourceSets.main)
        }
    }
}

sourceSets.main.resources { srcDir 'src/generated/resources' }

configurations {
    runtimeClasspath.extendsFrom localRuntime
}

dependencies {
    compileOnly(project(":loader").sourceSets.vulkanStartup.output)

    for (lib in vkJavaLibs) {
        implementation(lib)
        localRuntime(lib)
    }

    for (lib in nativeLibsToUse) {
        localRuntime(lib)
    }

    for (lib in loaderLibsToPack) {
        jijLib((String) lib)
    }
    jijMod(project(path: ":", configuration: "builtModJar"))
    loader(project(":loader"))
    localRuntime(project(':loader'))

    annotationProcessor 'systems.manifold:manifold-preprocessor:2025.1.26'
}

var generateModMetadata = tasks.register("generateModMetadata", ProcessResources) {
    var replaceProperties = [
            minecraft_version      : minecraft_version,
            minecraft_version_range: minecraft_version_range,
            neo_version            : neo_version,
            neo_version_range      : neo_version_range,
            loader_version_range   : loader_version_range,
            mod_id                 : mod_id,
            mod_name               : mod_name,
            mod_license            : mod_license,
            mod_version            : mod_version,
            mod_authors            : mod_authors,
            mod_description        : mod_description
    ]
    inputs.properties replaceProperties
    expand replaceProperties
    from "src/mod/templates"
    into "build/generated/sources/modMetadata"
}
sourceSets.main.resources.srcDir generateModMetadata
neoForge.ideSyncTask generateModMetadata

artifacts {
    builtModJar(tasks.jar.archiveFile) {
        builtBy(jar)
    }
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8' // Use the UTF-8 charset for Java compilation
}

// IDEA no longer automatically downloads sources/javadoc jars for dependencies, so we need to explicitly enable the behavior.
idea {
    module {
        downloadSources = true
        downloadJavadoc = true
    }
}

tasks.register('apiJar', Jar).configure { Jar jar1 ->
    jar1.duplicatesStrategy(DuplicatesStrategy.FAIL)
    jar1.archiveBaseName = "$mod_id-$minecraft_version"
    jar1.archiveClassifier = "api"
    jar1.from([
            sourceSets.api.output,
            sourceSets.api.allJava
    ])
}

tasks.register('sourcesJar', Jar).configure { Jar jar1 ->
    jar1.duplicatesStrategy(DuplicatesStrategy.FAIL)
    jar1.archiveClassifier = "sources"
    jar1.from([
            sourceSets.api.output,
            sourceSets.lib.output,
            sourceSets.mclib.output,
            sourceSets.mercury.output,
            sourceSets.core.output,
            sourceSets.main.output,
            project(':loader').sourceSets.vulkanStartup.output,
            project(':loader').sourceSets.main.output,
            sourceSets.api.allJava,
            sourceSets.lib.allJava,
            sourceSets.mclib.allJava,
            sourceSets.mercury.allJava,
            sourceSets.core.allJava,
            sourceSets.main.allJava,
            project(':loader').sourceSets.vulkanStartup.allJava,
            project(':loader').sourceSets.main.allJava,
    ])
}


tasks.named('jar', Jar).configure { Jar jar1 ->
    jar1.duplicatesStrategy(DuplicatesStrategy.FAIL)
    jar1.archiveVersion = jar1.archiveVersion.get() + "-packed"
    jar1.from([
            sourceSets.api.output,
            sourceSets.lib.output,
            sourceSets.mclib.output,
            sourceSets.mercury.output,
            sourceSets.core.output,
            sourceSets.main.output,
    ])
}

afterEvaluate {
    evaluationDependsOnChildren()

    tasks.register('fatJar', Jar).configure { Jar jar1 ->
        dependsOn(project(":loader").tasks.jar)
        jar1.duplicatesStrategy(DuplicatesStrategy.FAIL)
        jar1.archiveClassifier = ""
        jar1.from([
                configurations.loader.collect { it.isDirectory() ? it : zipTree(it) },
        ])
    }

    fatJar {
        manifest {
            attributes["FMLModType"] = "LIBRARY"
            attributes["Automatic-Module-Name"] = "cinnabar_locator"
        }
        into("META-INF/modjar") {
            from(configurations.jijMod)
        }
        from(configurations.jijLib.collect { it.isDirectory() ? it : zipTree(it) }) {
            exclude("META-INF/**")
            exclude("org/lwjgl/*")
            exclude("org/lwjgl/system/**")
        }
    }
}

tasks.named('wrapper', Wrapper).configure {
    distributionType = Wrapper.DistributionType.BIN
}

def curseforgeToken = System.getenv("curseforge_token")

def changelog = """
[https://github.com/RogueLogix/Cinnabar/blob/$version/changelog.md](https://github.com/RogueLogix/Cinnabar/blob/$version/changelog.md)
"""

// only enable this if we are the root project
// prevents accidentally publishing as submodule project
if (curseforgeToken != null && this.project == this.rootProject) {
    tasks.register('publishCurseForge', TaskPublishCurseForge) {
        
        apiToken = curseforgeToken
        def projectId = "552238"

        def mainFile = upload(projectId, fatJar)
        mainFile.changelog = changelog
        mainFile.changelogType = 'markdown'
        mainFile.releaseType = release_type
        mainFile.gameVersions.clear()
        mainFile.addGameVersion(minecraft_version)
        mainFile.addJavaVersion('Java 25')
        mainFile.addModLoader('NeoForge')

        mainFile.withAdditionalFile(apiJar)
        mainFile.withAdditionalFile(sourcesJar)

        mainFile.curseFileId
    }
}

afterEvaluate {
    publishing {
        repositories {
            maven {
                name = "logixdevSnapshots"
                url = "https://maven.logix.dev/snapshots"
                credentials(PasswordCredentials)
                authentication {
                    basic(BasicAuthentication)
                }
            }
            maven {
                name = "logixdevReleases"
                url = "https://maven.logix.dev/releases"
                credentials(PasswordCredentials)
                authentication {
                    basic(BasicAuthentication)
                }
            }
        }
        publications {
            NeoPublish(MavenPublication) {
                groupId = "graphics.cinnabar"
                artifactId = "cinnabar-neoforge"
                version = getGitDescribedVersionWithMcVersion()
                artifact sourcesJar
                artifact fatJar
            }
            ApiPublish(MavenPublication) {
                groupId = "graphics.cinnabar"
                artifactId = "cinnabar"
                version = getGitDescribedVersionWithMcVersion()
                artifact apiJar
            }
        }
    }

    project(":loader").compileVulkanStartupJava.options.compilerArgs += '-Xplugin:Manifold'
}

compileApiJava.options.compilerArgs += '-Xplugin:Manifold'
compileCoreJava.options.compilerArgs += '-Xplugin:Manifold'
compileLibJava.options.compilerArgs += '-Xplugin:Manifold'
compileMclibJava.options.compilerArgs += '-Xplugin:Manifold'
compileMercuryJava.options.compilerArgs += '-Xplugin:Manifold'
compileJava.options.compilerArgs += '-Xplugin:Manifold'

file("src/build.properties").text = """
// to switch mode, refresh the gradle project of the respective loader
NEO
"""
file("loader/src/build.properties").text = """
// to switch mode, refresh the gradle project of the respective loader
NEO
"""